from modules import common, actions, classes, cli
import sys, os, math, plistlib, signal, pprint, json
 


"""
COMMAND LINE INTERFACE OF THE PROJECT
"""

#--------------------------------------------------------------------------------------------------------------------------------

v = "v"  # the initial verboseness level

#--------------------------------------------------------------------------------------------------------------------------------

def cli_loop():
	""" command line loop """
	while 1:
		line = cli.inp()

		cmd = line.split(" ")[0]
		args = None
		if len(line.split(" ")) > 1:
			args = line.split(" ")[1:]

		if (cmd in menu.keys()):
			func = menu[cmd]
			func(args=args)
		else:
			print("unknown command:", cmd)

#--------------------------------------------------------------------------------------------------------------------------------

def gather_artefacts_all(args=None,h=False):
	""" exports dumps of all .sqlite and .plist filepaths in preprogrammed interesting locations """
	

	params_description = [\
	("Please, input a valid username to gather artefacts on","user",None)\
	]

	if (h):
		print("[?] gatherall <username>:\n    Scans a predefined list of folders based on the provided username") 
		print("    checks for all .plist files available, makes a .json dump of those for further usage")
		return

	params = cli.get_params(params_description, args)
	if params == None:
		return

	user = params[0]

	global v
	p = common.pseudonym_generate()
	plist  = actions.scanplaces_plist(user, pseudonym=p, verbose=v)
	plist.export_json(p+"_"+str(common.timestmap())+"_plist")

#--------------------------------------------------------------------------------------------------------------------------------

def exit_program(args=None,h=False):
	""" exits software """
	if (h):
		print("[?] exit\n    Exits OSXCAVATE. All unsaved data will be lost!")
		return
	print("\ngoodbye!\n")
	sys.exit()

#--------------------------------------------------------------------------------------------------------------------------------

def set_verbose(args=None,h=False):
	global v
	""" sets CLI verboseness """
	if (h):
		print("[?] verbose <level>\n    Sets the level of verbosity for the command line interface")
		return

	opts = ["n", "v", "vv", "vvv"]

	params_description = [\
	("Select between no output (n), verbose (v), very verbose (vv) or very very verbose (vvv)","inlist",opts)\
	]

	params = cli.get_params(params_description, args)
	if params == None:
		return

	v = params[0]

#--------------------------------------------------------------------------------------------------------------------------------

def rank_plists(args=None, h=False):

	""" a loop for manually ranking plist files from common_files-generated list """

	
	mode_options = ["rank", "count", "filenames"]

	params_description = [\
	("Select input file - has to be a list of filenames generated by common_files","file"),\
	("Please, input a valid username to access artefacts of","user"),\
	("Select one of operation modes: rank, count, filenames","inlist",mode_options)\
	]


	if (h):
		print("[?] rankplists <file> <username> <mode>\n    manually assign rank/groups to plist files from a common_files-generated list")
		return


	params = cli.get_params(params_description, args)
	if params == None:
		return

	filename, user, mode = params[0], params[1], params[2]


	files = []
	fh = open(filename, 'r')
	for line in fh:
		files.append(common.template_fill_field(line, 'user', user).replace("\n", "").strip())
	fh.close()

	


	count = 0
	livefiles = []

	for f in files:
		fh = None
		try:
			fh = open(os.path.realpath(f), 'rb')
		except Exception as e:
			if (v == "vvv"):
				print("[x] failed to open "+f+"; file likely missing")
		if not fh == None:
			livefiles.append(f)
			count += 1
			fh.close()

	if mode == "count":
		print("listed filepath count:",len(files))
		print("located file count:   ",count)
	elif mode == "filenames":
		fname = "rankplists_files_"+str(common.timestmap())+".txt"
		fpath = os.path.join(os.path.join(os.getcwd(), "exports/rankplists/"), fname)	
		common.strlist_to_file(fpath, livefiles, v)
	elif mode == "rank":
		groups = ["geo","language","datetime","web","ip","name","data","path","other"]
		ranks = ["s", "a", "b", "c", ""]
		counter = 1
		


		out_data = []

		for f in livefiles:
			clear()
			data_row = {"path":None,"groups":None,"rank":None,"comment":None}

			fh = open(os.path.realpath(f), 'rb')
			print("file "+str(counter)+"/"+str(len(livefiles))+":",f,"\n")

			try:
				plistcontents = plistlib.load(fh)
				print("\n")
				pprint.pprint(plistcontents)
				print("\n")
			except Exception as e:
				print("\ncould not parse file contents - do not rank the file")
			fh.close()
			
			

			counter += 1

			# set groups
			line = ""
			for x in range(len(groups)):
				if x > 0:
					line += " / "
				line += str(x)+"."+groups[x]
			print("\nSet groups with digits as one number or Enter for no groups:\n"+line)
			while (1):
				line = cli.inp()
				if line == "": # no groups selected
					break
				else:
					if not cli.param_validate(line, "int_pos") == None:
						outgroups = []
						for g in line:
							tempg = int(g)
							if tempg > len(groups):
								print("[i]",tempg,"out of possible groups range")
							else:
								outgroups.append(groups[tempg])
						data_row["groups"]=outgroups
						break
			# set rank
			print("\nSet rank: S, A, B, C or just enter for No rank (discard file)")
			outrank = cli.param_read("inlist", ranks)
			if outrank == "":
				continue
			data_row["rank"] = outrank

			# set comment
			print("\nAdd arbitrary comment (keep it short, hit enter = no comment)")
			line = cli.inp().strip()
			if not line == "":
				data_row["comment"] = line

			data_row["path"] = f

			out_data.append(data_row)

		name = "rankings_"+str(common.timestmap())+".json"
		fname = os.path.join(os.path.join(os.getcwd(), "exports/rankplists"), name)
		out = common.str_to_file(fname, json.dumps(out_data, indent=4), v)

		clear()

		print("ranking finished successfully")

	return

#--------------------------------------------------------------------------------------------------------------------------------

def excavate(args=None,h=False):
	""" excavates interesting files by the built-in .json list, exports to /exports/excavate """
	global v

	if (h):
		print("[?] excavate <username>\n    gathers known artefacts from this system for a particular user")
		return

	params_description = [\
	("Please, input a valid username to export artefacts of","user",None)\
	]

	params = cli.get_params(params_description, args)
	if params == None:
		return

	user = params[0]
	export_path = os.path.join(os.getcwd(), "exports/excavate", "excavation_"+str(common.timestmap()))
	os.makedirs(export_path)
	for subf in ["s","a","b","c"]:
		os.makedirs(os.path.join(export_path, subf))

	artefacts_store = os.path.join(os.getcwd(), "lists/bundled/files.json")
	fh = open(artefacts_store, 'r')
	contents = fh.read()
	fh.close()
	artefacts = json.loads(contents)
	
	actions.export_artefacts(user, artefacts, export_path, v)


#--------------------------------------------------------------------------------------------------------------------------------

def common_files(args=None,h=False):
	
	""" finds overlapping files between json dumps from /datasource/json """
	global v

	if (h):
		print("[?] commonfiles <tolerance>\n    compares existing data dumps and finds out which files exist across all of them")
		return
	opts = ["json"]

	params_description = [\
	("Input elimination tolerance - positive integer less than number of data dumps processed","int_pos")\
	]

	params = cli.get_params(params_description, args)
	if params == None:
		return

	tolerance = params[0]
	method = "json" # this is here so that maybe later on some other data storing method gets added
	if (method == "json"):
		source = "datasource/json"

	out = actions.overlapping_files(source, method, tolerance, v)
	if out == False:
		return

	fname = "commonfiles_"+str(common.timestmap())+".txt"
	fpath = os.path.join(os.path.join(os.getcwd(), "exports/commonfiles/"), fname)
	common.strlist_to_file(fpath, out, v)
	print("Wrote a list of", len(out) ,"overlapping files to", fname)


#--------------------------------------------------------------------------------------------------------------------------------

def clear(h=False, args=None):
	""" clear the screen """
	if (h):
		print("[?] clear\n    removes all lines from screen")
		return
	common.clear();

#--------------------------------------------------------------------------------------------------------------------------------

def get_help(h=False, args=None):
	""" help message """
	if (h):
		print("[?] help <optional:command>\n    Displays general help or help on specific commands (help <command>)")
		return
	if (args == None):
		print("\nAvailable actions - run without arguments for live interactive prompting:")
		for k in menu.keys():
			print("  "+k)
		print("\nUse help <command1> (<command2> ...) for specific help messages\n")
	else:
		for arg in args:
			if arg in menu.keys():
				func = menu[arg]
				func(h=True)

#--------------------------------------------------------------------------------------------------------------------------------

menu = {
	"exit": exit_program,
	"verbose": set_verbose,
	"help": get_help,
	"clear": clear,
	"gatherall": gather_artefacts_all,
	"commonfiles": common_files,
	"rankplists": rank_plists,
	"excavate": excavate,
}
menu = dict(sorted(menu.items()))


#--------------------------------------------------------------------------------------------------------------------------------

clear()
print("================ OSXCAVATE ================\ntype 'help' to see available commands...\n\n")
cli_loop()

#--------------------------------------------------------------------------------------------------------------------------------